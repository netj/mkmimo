#!/usr/bin/env coffee
# mkmimo -- Create a multiple inputs/multiple outputs
# > mkmimo [INPUT... \>] OUTPUT...
# Reads lines from available INPUTs and writes to available OUTPUTs without
# blocking.
# 
# This utility is ideal for connecting a set of parallel processes, whose
# inputs and outputs are exposed via named pipes created with mkfifo(1), or
# with bash process substitution.
#
# Author: Jaeho Shin <netj@cs.stanford.edu>
# Created: 2015-03-03

fs = require "fs"
byline = require "byline"
args = process.argv[2..]

PUMP_IDLE_MS = 1000 #ms
NUM_LINES_TO_READ_PER_INPUT = 10

# find input and output paths from arguments
ioSepIdx = args.indexOf ">"
if ioSepIdx > 0
    inputPaths = args[0...ioSepIdx]
    outputPaths = args[(ioSepIdx+1)..]
else
    inputPaths = ["/dev/stdin"]
    outputPaths = args
if outputPaths.length == 0
    outputPaths = ["/dev/stdout"]

# open input and output paths
inputStreams =
    for path in inputPaths
        byline fs.createReadStream path
outputStreams =
    for path in outputPaths
        fs.createWriteStream path

# callbacks for maintaining stream states
willPump = null
inputsReadable = []
outputsWritable = (o for o in outputStreams)
numInputsClosed = 0
canRead = (i) -> ->  inputsReadable.push inputStreams[i];   willPump = setImmediate pump unless willPump?
canWrite = (j) -> -> outputsWritable.push outputStreams[j]; willPump = setImmediate pump unless willPump?
closedInput = (i) -> -> ++numInputsClosed
# and the main pumping function
j = 0
pump = ->
    willPump = null
    if inputsReadable.length > 0 and outputsWritable.length > 0
        i = inputsReadable.length
        while i--
            input = inputsReadable[i]
            for k in [0...NUM_LINES_TO_READ_PER_INPUT]
                # read a line from input
                unless (line = input.read())?
                    # mark input as drained if no lines came back
                    inputsReadable.splice i, 1
                    break
                # write to next available output
                output = outputsWritable[j = (j - 1) %% outputsWritable.length]
                output.write line
                unless output.write "\n"
                    # mark output as full if write wasn't smooth
                    outputsWritable.splice j, 1
                    break unless outputsWritable.length > 0
            break unless outputsWritable.length > 0
    # repeat pumping until all inputs are closed
    if numInputsClosed == inputStreams.length
        output.end() for output in outputStreams
    else if inputsReadable.length > 0 and outputsWritable.length > 0
        willPump = setImmediate pump

# read lines from inputs
for stream,i in inputStreams
    stream.on "readable", canRead i
    stream.on "end", closedInput i
    stream.on "close", closedInput i
for stream,j in outputStreams
    stream.on "drain", canWrite j
do pump
